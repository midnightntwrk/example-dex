pragma language_version >= 0.16;

import CompactStandardLibrary;
import "./oz/FungibleToken" prefix FooToken_;
import "./oz/FungibleToken" prefix BarToken_;

export enum Token { foo, bar }

export sealed ledger admin: ZswapCoinPublicKey;
export ledger alreadyMinted: Set<ZswapCoinPublicKey>;
export ledger liquidityProviders: Map<[ZswapCoinPublicKey, Token], Uint<128>>; // (user, token_color) -> amount
sealed ledger mintAmount: Uint<64>;

witness amountsToSwap(): [Uint<128>, Uint<128>]; // [amountToBuy, amountToSell]

constructor(
    names: [Opaque<"string">, Opaque<"string">],
    symbols: [Opaque<"string">, Opaque<"string">],
    fixedSupply: Uint<64>
) {
    FooToken_initialize(names[0], symbols[0], 18);
    BarToken_initialize(names[1], symbols[1], 18);
    admin = ownPublicKey();
    // the total supply is owned by the contract
    FooToken__mint(
        right<ZswapCoinPublicKey, ContractAddress>(kernel.self()),
        fixedSupply
    );
    BarToken__mint(
        right<ZswapCoinPublicKey, ContractAddress>(kernel.self()),
        fixedSupply
    );
}

export circuit addLiquidity(
    token: Token,
    amount: Uint<64>,
) {
    // checks if the user has enough tokens
    const user = ownPublicKey();
    const userBalance = 
}